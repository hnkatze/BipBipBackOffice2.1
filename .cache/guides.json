[
  [
    "theming",
    {
      "data": {
        "name": "theming",
        "title": "Theming",
        "description": "Choose from a variety of pre-styled themes or develop your own.",
        "sections": [
          {
            "heading": "Architecture",
            "content": "Choose from a variety of pre-styled themes or develop your own.\n\nPrimeNG is a design agnostic library so unlike some other UI libraries it does not enforce a certain styling such as material design. Styling is decoupled from the components using the themes instead. A theme consists of two parts; base and preset. The base is the style rules with CSS variables as placeholders whereas the preset is a set of design tokens to feed a base by mapping the tokens to CSS variables. A base may be configured with different presets, currently Aura, Material, Lara and Nora are the available built-in options.\n\nThe core of the styled mode architecture is based on a concept named design token, a preset defines the token configuration in 3 tiers; primitive, semantic and component.\n\nPrimitive tokens have no context, a color palette is a good example for a primitive token such as blue-50 to blue-900. A token named blue-500 may be used as the primary color, the background of a message however on its own, the name of the token does not indicate context. Usually they are utilized by the semantic tokens.",
            "codeBlocks": [
              "import { ApplicationConfig } from '@angular/core';\nimport { provideAnimationsAsync } from '@angular/platform-browser/animations/async';\nimport { providePrimeNG } from 'primeng/config';\nimport Aura from '@primeuix/themes/aura';\n\nexport const appConfig: ApplicationConfig = {\n    providers: [\n        provideAnimationsAsync(),\n        providePrimeNG({\n            theme: {\n                preset: Aura\n            }\n        })\n    ]\n};",
              "options: {\n    prefix: 'my'\n}",
              "options: {\n    darkModeSelector: '.my-app-dark'\n}"
            ]
          },
          {
            "heading": "Configuration API",
            "content": "Semantic tokens define content and their names indicate where they are utilized, a well known example of a semantic token is the primary.color. Semantic tokens map to primitive tokens or other semantic tokens. The colorScheme token group is a special variable to define tokens based on the color scheme active in the application, this allows defining different tokens based on the color scheme like dark mode.\n\nComponent tokens are isolated tokens per component such as inputtext.background or button.color that map to the semantic tokens. As an example, button.background component token maps to the primary.color semantic token which maps to the green.500 primitive token.\n\nUse primitive tokens when defining the core color palette and semantic tokens to specify the common design elements such as focus ring, primary colors and surfaces. Components tokens should only be used when customizing a specific component. By defining your own design tokens as a custom preset, you'll be able to define your own style without touching CSS. Overriding the PrimeNG components using style classes is not a best practice and should be the last resort, design tokens are the suggested approach.\n\nThe theme property is used to customize the initial theme.",
            "codeBlocks": [
              "options: {\n    cssLayer: {\n        name: 'primeng',\n        order: 'app-styles, primeng, another-css-library'\n    }\n}",
              "// With CSS\nvar(--p-blue-500)\n\n// With JS\n$dt('blue.500').value",
              "providePrimeNG({\n    theme: {\n        preset: Aura,\n        options: {\n            darkModeSelector: '.my-app-dark'\n        }\n    }\n})"
            ]
          },
          {
            "heading": "Presets",
            "content": "The options property defines the how the CSS would be generated from the design tokens of the preset.\n\nThe prefix of the CSS variables, defaults to p. For instance, the primary.color design token would be var(--p-primary-color).\n\nThe CSS rule to encapsulate the CSS variables of the dark mode, the default is the system to generate @media (prefers-color-scheme: dark). If you need to make the dark mode toggleable based on the user selection define a class selector such as .app-dark and toggle this class at the document root. See the dark mode toggle section for an example.\n\nDefines whether the styles should be defined inside a CSS layer by default or not. A CSS layer would be handy to declare a custom cascade layer for easier customization if necessary. The default is false.",
            "codeBlocks": [
              "<p-button label=\"Toggle Dark Mode\" (onClick)=\"toggleDarkMode()\"/>",
              "toggleDarkMode() {\n    const element = document.querySelector('html');\n    element.classList.toggle('my-app-dark');\n}",
              "<html class=\"my-app-dark\">"
            ]
          },
          {
            "heading": "Reserved Keys",
            "content": "Aura, Material, Lara and Nora are the available built-in options, created to demonstrate the power of the design-agnostic theming. Aura is PrimeTek's own vision, Material follows Google Material Design v2, Lara is based on Bootstrap and Nora is inspired by enterprise applications. Visit the source code to learn more about the structure of presets. You may use them out of the box with modifications or utilize them as reference in case you need to build your own presets from scratch.\n\nFollowing keys are reserved in the preset scheme and cannot be used as a token name; primitive, semantic, components, directives, colorscheme, light, dark, common, root, states and extend.\n\nColor palette of a preset is defined by the primitive design token group. You can access colors using CSS variables or the $dt utility.\n\nPrimeNG uses the system as the default darkModeSelector in theme configuration. If you have a dark mode switch in your application, set the darkModeSelector to the selector you utilize such as .my-app-dark so that PrimeNG can fit in seamlessly with your color scheme.",
            "codeBlocks": [
              "providePrimeNG({\n    theme: {\n        preset: Aura,\n        options: {\n            darkModeSelector: false || 'none'\n        }\n    }\n})",
              "//mypreset.ts\nimport { definePreset } from '@primeuix/themes';\nimport Aura from '@primeuix/themes/aura';\n\nconst MyPreset = definePreset(Aura, {\n    //Your customizations, see the following sections for examples\n});\n\nexport MyPreset;",
              "import { ApplicationConfig } from '@angular/core';\nimport { provideAnimationsAsync } from '@angular/platform-browser/animations/async';\nimport { providePrimeNG } from 'primeng/config';\nimport MyPreset from './mypreset';\n\nexport const appConfig: ApplicationConfig = {\n    providers: [\n        provideAnimationsAsync(),\n        providePrimeNG({\n            theme: {\n                preset: MyPreset\n            }\n        })\n    ]\n};"
            ]
          },
          {
            "heading": "Colors",
            "content": "Following is a very basic example implementation of a dark mode switch, you may extend it further by involving prefers-color-scheme to retrieve it from the system initially and use localStorage to make it stateful. See this article for more information.\n\nIn case you prefer to use dark mode all the time, apply the darkModeSelector initially and never change it.\n\nIt is also possible to disable dark mode completely using false or none as the value of the selector.\n\nThe definePreset utility is used to customize an existing preset during the PrimeNG setup. The first parameter is the preset to customize and the second is the design tokens to override.",
            "codeBlocks": [
              "import { bootstrapApplication } from '@angular/platform-browser';\nimport { providePrimeNG } from 'primeng/config';\nimport { definePreset } from '@primeuix/themes';\nimport Aura from '@primeuix/themes/aura';\nimport { AppComponent } from './app/app.component';\n\nconst MyPreset = definePreset(Aura, {\n    semantic: {\n        colorScheme: {\n            light: {\n                //...\n            },\n            dark: {\n                //...\n            }\n        }\n    }\n});\n\nbootstrapApplication(AppComponent, {\n    providers: [\n        providePrimeNG({\n            theme: {\n                preset: MyPreset\n            }\n        })\n    ]\n});",
              "/* Fails as Aura defines highlight tokens in colorScheme */\nconst MyPreset = definePreset(Aura, {\n    semantic: {\n        highlight: {\n            background: '{primary.50}',\n            color: '{primary.700}',\n        }\n    }\n});",
              "/* Works because highlight tokens are defined under colorScheme */\nconst MyPreset = definePreset(Aura, {\n    semantic: {\n        colorScheme: {\n            light: {\n                semantic: {\n                    highlight: {\n                        background: '{primary.50}',\n                        color: '{primary.700}',\n                    }\n                }\n            },\n            dark: {\n                semantic: {\n                    highlight: {\n                        background: '{primary.200}',\n                        color: '{primary.900}',\n                    }\n                }\n            }\n        }\n    }\n});"
            ]
          },
          {
            "heading": "Dark Mode",
            "content": "A token can be defined per color scheme using light and dark properties of the colorScheme property. Each token can have specific values based on the current color scheme.\n\nWhen customizing an existing preset, your token overrides may be ignored if you don't properly account for color scheme variations. If the original preset defines a token using the colorScheme property, but your customization only provides a direct value, your override will be ignored because the colorScheme property takes precedence over direct values and the system will continue using the preset's scheme-specific values. When customizing tokens that are not defined with colorScheme in the original preset, your customizations will be applied successfully regardless of how you structure them; whether direct or under colorScheme.\n\nThis approach ensures your customizations will be applied correctly regardless of the user's selected color scheme.\n\nThe primary defines the main color palette, default value maps to the emerald primitive token. Let's setup to use indigo instead.",
            "codeBlocks": [
              "const MyPreset = definePreset(Aura, {\n    semantic: {\n        primary: {\n            50: '{indigo.50}',\n            100: '{indigo.100}',\n            200: '{indigo.200}',\n            300: '{indigo.300}',\n            400: '{indigo.400}',\n            500: '{indigo.500}',\n            600: '{indigo.600}',\n            700: '{indigo.700}',\n            800: '{indigo.800}',\n            900: '{indigo.900}',\n            950: '{indigo.950}'\n        }\n    }\n});",
              "const MyPreset = definePreset(Aura, {\n    semantic: {\n        colorScheme: {\n            light: {\n                surface: {\n                    0: '#ffffff',\n                    50: '{zinc.50}',\n                    100: '{zinc.100}',\n                    200: '{zinc.200}',\n                    300: '{zinc.300}',\n                    400: '{zinc.400}',\n                    500: '{zinc.500}',\n                    600: '{zinc.600}',\n                    700: '{zinc.700}',\n                    800: '{zinc.800}',\n                    900: '{zinc.900}',\n                    950: '{zinc.950}'\n                }\n            },\n            dark: {\n                surface: {\n                    0: '#ffffff',\n                    50: '{slate.50}',\n                    100: '{slate.100}',\n                    200: '{slate.200}',\n                    300: '{slate.300}',\n                    400: '{slate.400}',\n                    500: '{slate.500}',\n                    600: '{slate.600}',\n                    700: '{slate.700}',\n                    800: '{slate.800}',\n                    900: '{slate.900}',\n                    950: '{slate.950}'\n                }\n            }\n        }\n    }\n});",
              "const Noir = definePreset(Aura, {\n    semantic: {\n        primary: {\n            50: '{zinc.50}',\n            100: '{zinc.100}',\n            200: '{zinc.200}',\n            300: '{zinc.300}',\n            400: '{zinc.400}',\n            500: '{zinc.500}',\n            600: '{zinc.600}',\n            700: '{zinc.700}',\n            800: '{zinc.800}',\n            900: '{zinc.900}',\n            950: '{zinc.950}'\n        },\n        colorScheme: {\n            light: {\n                primary: {\n                    color: '{zinc.950}',\n                    inverseColor: '#ffffff',\n                    hoverColor: '{zinc.900}',\n                    activeColor: '{zinc.800}'\n                },\n                highlight: {\n                    background: '{zinc.950}',\n                    focusBackground: '{zinc.700}',\n                    color: '#ffffff',\n                    focusColor: '#ffffff'\n                }\n            },\n            dark: {\n                primary: {\n                    color: '{zinc.50}',\n                    inverseColor: '{zinc.950}',\n                    hoverColor: '{zinc.100}',\n                    activeColor: '{zinc.200}'\n                },\n                highlight: {\n                    background: 'rgba(250, 250, 250, .16)',\n                    focusBackground: 'rgba(250, 250, 250, .24)',\n                    color: 'rgba(255,255,255,.87)',\n                    focusColor: 'rgba(255,255,255,.87)'\n                }\n            }\n        }\n    }\n});"
            ]
          },
          {
            "heading": "Customization",
            "content": "The color scheme palette that varies between light and dark modes is specified with the surface tokens. Example below uses zinc for light mode and slategray for dark mode. With this setting, light mode, would have a grayscale tone and dark mode would include bluish tone.\n\nThe noir mode is the nickname of a variant that uses surface tones as the primary and requires and additional colorScheme configuration to implement. A sample preset configuration with black and white variants as the primary color;\n\nThere is no design for fonts as UI components inherit their font settings from the application.\n\nThe design tokens of the form input components are derived from the form.field token group. This customization example changes border color to primary on hover. Any component that depends on this semantic token such as dropdown.hover.border.color and textarea.hover.border.color would receive the change.",
            "codeBlocks": [
              "const MyPreset = definePreset(Aura, {\n    semantic: {\n        colorScheme: {\n            light: {\n                formField: {\n                    hoverBorderColor: '{primary.color}'\n                }\n            },\n            dark: {\n                formField: {\n                    hoverBorderColor: '{primary.color}'\n                }\n            }\n        }\n    }\n});",
              "const MyPreset = definePreset(Aura, {\n    semantic: {\n        focusRing: {\n            width: '2px',\n            style: 'dashed',\n            color: '{primary.color}',\n            offset: '1px'\n        }\n    }\n});",
              "const MyPreset = definePreset(Aura, {\n    components: {\n        card: {\n            colorScheme: {\n                light: {\n                    root: {\n                        background: '{surface.0}',\n                        color: '{surface.700}'\n                    },\n                    subtitle: {\n                        color: '{surface.500}'\n                    }\n                },\n                dark: {\n                    root: {\n                        background: '{surface.900}',\n                        color: '{surface.0}'\n                    },\n                    subtitle: {\n                        color: '{surface.400}'\n                    }\n                }\n            }\n        }\n    }\n});"
            ]
          },
          {
            "heading": "Scoped Tokens",
            "content": "Focus ring defines the outline width, style, color and offset. Let's use a thicker ring with the primary color for the outline.\n\nThe design tokens of a specific component is defined at components layer. Overriding components tokens is not the recommended approach if you are building your own style, building your own preset should be preferred instead. This configuration is global and applies to all card components, in case you need to customize a particular component on a page locally, view the Scoped CSS section for an example.\n\nThe theming system can be extended by adding custom design tokens and additional styles. This feature provides a high degree of customization, allowing you to adjust styles according to your needs, as you are not limited to the default tokens.\n\nThe example preset configuration adds a new accent button with custom button.accent.color and button.accent.inverse.color tokens. It is also possible to add tokens globally to share them within the components.",
            "codeBlocks": [
              "const MyPreset = definePreset(Aura, {\n    components: {\n        // custom button tokens and additional style\n        button: {\n            extend: {\n                accent: {\n                    color: '#f59e0b',\n                    inverseColor: '#ffffff'\n                }\n            }\n            css: ({ dt }) => `\n.p-button-accent {\n    background: ${dt('button.accent.color')};\n    color: ${dt('button.accent.inverse.color')};\n    transition-duration: ${dt('my.transition.fast')};\n}\n`\n        }\n    },\n    // common tokens and styles\n    extend: {\n        my: {\n            transition: {\n                slow: '0.75s'\n                normal: '0.5s'\n                fast: '0.25s'\n            },\n            imageDisplay: 'block'\n        }\n    },\n    css: ({ dt }) => `\n        /* Global CSS */\n        img {\n            display: ${dt('my.image.display')};\n        }\n    `\n});",
              "import { Component } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { ToggleSwitch } from 'primeng/toggleswitch';\n\n@Component({\n    template: `\n        <p-toggleswitch [(ngModel)]=\"checked1\"/>\n        <p-toggleswitch [(ngModel)]=\"checked2\" [dt]=\"amberSwitch\"/>\n    `,\n    standalone: true,\n    imports: [ToggleSwitch, FormsModule]\n})\nexport class AppComponent {\n\n    checked1: boolean = true;\n\n    checked2: boolean = true;\n\n    amberSwitch = {\n        handle: {\n            borderRadius: '4px'\n        },\n        colorScheme: {\n            light: {\n                root: {\n                    checkedBackground: '{amber.500}',\n                    checkedHoverBackground: '{amber.600}',\n                    borderRadius: '4px'\n                },\n                handle: {\n                    checkedBackground: '{amber.50}',\n                    checkedHoverBackground: '{amber.100}'\n                }\n            },\n            dark: {\n                root: {\n                    checkedBackground: '{amber.400}',\n                    checkedHoverBackground: '{amber.300}',\n                    borderRadius: '4px'\n                },\n                handle: {\n                    checkedBackground: '{amber.900}',\n                    checkedHoverBackground: '{amber.800}'\n                }\n            }\n        }\n    };\n}",
              "import { usePreset } from '@primeuix/themes';"
            ]
          },
          {
            "heading": "Utils",
            "content": "Design tokens can be scoped to a certain component using the dt property. In this example, first switch uses the global tokens whereas second one overrides the global with its own tokens.\n\nThis approach is recommended over the ::ng-deep as it offers a cleaner API while avoiding the hassle of CSS rule overrides.\n\nReplaces the current presets entirely, common use case is changing the preset dynamically at runtime.\n\nMerges the provided tokens to the current preset, an example would be changing the primary color palette dynamically.",
            "codeBlocks": [
              "onButtonClick() {\n    usePreset(MyPreset);\n}",
              "import { updatePreset } from '@primeuix/themes';",
              "changePrimaryColor() {\n    updatePreset({\n        semantic: {\n            primary: {\n                50: '{indigo.50}',\n                100: '{indigo.100}',\n                200: '{indigo.200}',\n                300: '{indigo.300}',\n                400: '{indigo.400}',\n                500: '{indigo.500}',\n                600: '{indigo.600}',\n                700: '{indigo.700}',\n                800: '{indigo.800}',\n                900: '{indigo.900}',\n                950: '{indigo.950}'\n            }\n        }\n    })\n}"
            ]
          },
          {
            "heading": "CSS Layer",
            "content": "Updates the primary colors, this is a shorthand to do the same update using updatePreset.\n\nUpdates the surface colors, this is a shorthand to do the same update using updatePreset.\n\nThe $dt function returns the information about a token like the full path and value. This would be useful if you need to access tokens programmatically.\n\nReturns shades and tints of a given color from 50 to 950 as an array.",
            "codeBlocks": [
              "import { updatePrimaryPalette } from '@primeuix/themes';",
              "changePrimaryColor() {\n    updatePrimaryPalette({\n        50: '{indigo.50}',\n        100: '{indigo.100}',\n        200: '{indigo.200}',\n        300: '{indigo.300}',\n        400: '{indigo.400}',\n        500: '{indigo.500}',\n        600: '{indigo.600}',\n        700: '{indigo.700}',\n        800: '{indigo.800}',\n        900: '{indigo.900}',\n        950: '{indigo.950}'\n    });\n}",
              "import { updateSurfacePalette } from '@primeuix/themes';"
            ]
          },
          {
            "heading": "Scale",
            "content": "The @layer is a standard CSS feature to define cascade layers for a customizable order of precedence. If you need to become more familiar with layers, visit the documentation at MDN to begin with.\n\nThe cssLayer is disabled by default, when it is enabled at theme configuration, PrimeNG wraps the built-in style classes under the primeng cascade layer to make the library styles easy to override. CSS in your app without a layer has the highest CSS specificity, so you'll be able to override styles regardless of the location or how strong a class is written.\n\nIn case PrimeNG components have visual issues in your application, a Reset CSS may be the culprit. CSS layers would be an efficient solution that involves enabling the PrimeNG layer, wrapping the Reset CSS in another layer and defining the layer order. This way, your Reset CSS does not get in the way of PrimeNG components.\n\nPrimeNG UI component use rem units, 1rem equals to the font size of the html element which is 16px by default. Use the root font-size to adjust the size of the components globally. This website uses 14px as the base so it may differ from your application if your base font size is different.",
            "codeBlocks": [
              "changeSurfaces() {\n    //changes surfaces both in light and dark mode\n    updateSurfacePalette({\n        50: '{zinc.50}',\n        // ...\n        950: '{zinc.950}'\n    });\n}",
              "const changeLightSurfaces() {\n    //changes surfaces only in light\n    updateSurfacePalette({\n        light: {\n            50: '{zinc.50}',\n            // ...\n            950: '{zinc.950}'\n        }\n    });\n}",
              "function changeDarkSurfaces() {\n    //changes surfaces only in dark mode\n    updateSurfacePalette({\n        dark: {\n            50: '{zinc.50}',\n            // ...\n            950: '{zinc.950}'\n        }\n    });\n}",
              "import { $dt } from '@primeuix/themes';",
              "const duration = $dt('transition.duration');\n/*\n    duration: {\n        name: '--transition-duration',\n        variable: 'var(--p-transition-duration)',\n        value: '0.2s'\n    }\n*/\n\nconst primaryColor = $dt('primary.color');\n/*\n    primaryColor: {\n        name: '--primary-color',\n        variable: 'var(--p-primary-color)',\n        value: {\n        light: {\n            value: '#10b981',\n            paths: {\n                name: 'semantic.primary.color',\n                binding: {\n                    name: 'primitive.emerald.500'\n                }\n            }\n        },\n        dark: {\n            value: '#34d399',\n            paths: {\n                name: 'semantic.primary.color',\n                binding: {\n                    name: 'primitive.emerald.400'\n                }\n            }\n        }\n    }\n}\n*/",
              "import { palette } from '@primeuix/themes';",
              "// custom color\nconst values1 = palette('#10b981');\n\n// copy an existing token set\nconst primaryColor = palette('{blue}');",
              "/* Order */\n@layer reset, primeng;\n\n/* Reset CSS */\n@layer reset {\n    button,\n    input {\n        /* CSS to Reset */\n    }\n}",
              "html {\n    font-size: 14px;\n}"
            ]
          }
        ],
        "url": "https://primeng.org/theming"
      },
      "timestamp": 1763579191281,
      "ttl": 86400000
    }
  ]
]